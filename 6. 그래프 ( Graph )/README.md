### 그래프 ( Graph ) 란

![image](https://github.com/pastjung/DataStructure/assets/87860163/4ec8b377-956d-4b6f-898b-3f6b5cdbe921)

- 노드 ( Node 혹은 Vertices : 정점 ) 사이에 간선 ( Edge ) 가 있는 Collection
- 방향의 유무에 따라 무향/유향 그래프가 된다.
- 그래프로 구조를 어떻게 설계 그리고 무엇을 (검색, 추가, 삭제 등) 하고 싶으냐에 따라 시간 복잡도가 달라진다

### 시간 복잡도

- 그래프가 리스트 형태로 설계 되어 있는 경우 N = node, E = edge 로 표시한다

| 자료구조 | 검색 ( 값 ) | 노드 추가 (add) | 노드 삭제 (delete) | 간선 삭제 (delete) |
| --- | --- | --- | --- | --- |
| Graph | O( | N | + | E | ) | O(1) | O( | N | + | E | ) | O(  | E | ) |

### 장점

- 새로운 요소들의 추가/삭제가 용이하고 효율적이다
- 복잡한 관계를 직관적으로 표현할 수 있다.
- 다양한 최적화 문제를 풀 수 있다
ex. 최단 경로 문제, 최소 신장 트리 문제 등
- 구조의 응용이 가능하다

### 단점

- 노드와 간선이 많아질수록 그래프의 구조와 연결 관계를 관리하는 것이 복잡해진다.
- 복잡한 그래프에서는 경로 탐색 같은 연산이 복잡하고 시간이 많이 결릴 수 있다.
- 노드와 간선의 정보를 저장하기 위해 많은 메모리를 필요로 한다
특히 밀집 그래프 (Dense Graph) 의 경우 노드 간의 많은 연결을 저장해야 한다.

### 특징 및 종류

- **무방향성 ( Unidirectionality )**
  - 그래프의 간선은 방향성이 없을 수 있으며, **양쪽 방향으로 모두 이동 가능**
  - 이러한 그래프를 무방향 그래프 ( Undirected Graph ) 라고 부름
- **방향성 ( Directionality )**
  - 그래프의 간선은 방향성이 있을 수 있으며, **한쪽 방향으로만 이동 가능**
  - 이러한 그래프를 **방향 그래프 ( Directed Graph )** 또는 **유향 그래프 ( Digraph )** 라고 부름
- **가중치 ( Weight )**
  - 그래프의 **간선에 가중치를 부여**할 수 있다.
  - 보통은 거리, 비용, 우선순위 등을 나타내는데 사용
  - 이러한 그래프를 **가중치 그래프 ( Weighted Graph )** 라고 부름
- **연결성 ( Connectivity )**
  - 노드와 노드 사이에 경로가 존재하면, 두 노드는 연결되었다고 말한다
  - 그래프가 연결되어 있는 경우 **연결 그래프 ( Connected Graph )** 라고 부름
  - 그래프가 연결되어 있는 않은 경우 **비연결 그래프 ( Disconnected Graph )** 라고 부름
- **사이클 ( Cycle )**
  - 그래프에서 **한 노드에서 시작하여 경로를 따라가면서 최종적으로 자기 자신으로 돌아오는 경로**를 말함
  - 사이클이 있는 그래프를 **순환 그래프 ( Cyclic Graph )** 라고 부름
  - 사이클이 없는 그래플르 **비순환 그래프 ( Acyclic Graph )** 라고 부름
- **차수 ( Degree )**
  - 그래프에서 **한 노드에 인접한 간서의 수**를 말함
  - 무방향 그래프에서는 노드의 차수가 연결된 노드의 수와 같으며,
  - 방향 그래프에서는 인접한 노드의 수와 나가는 노드의 수로 구분된다.
- **인접 노드 ( Adjacent Nodes 혹은 Adjacent Vertices )**
  - 특정 노드에서 직접적으로 갈 수 있는 노드들을 말함
  - 보통 **인접 노드들을 묶어 놓은 것을 Level** 이라고 한다.

### 종류

![image](https://github.com/pastjung/DataStructure/assets/87860163/c7b87374-cb01-4602-b46c-92be8cbcc271)

- **무향 그래프 / 무방향 그래프 ( Undirected Graph )**
    - 간선에 방향이 없는 그래프
    - 노드와 간선으로만 이루어져 있으며, 노드 사이의 관계는 양방향이다
- **유향 그래프 / 방향 그래프 ( Digraph, Directed Graph )**
    - 간선에 방향이 있는 그래프
    - 노드와 간선으로 이루어져 있으며, 노드 사이의 관계는 일방향이다
- **가중치 그래프 ( Weighted Graph )**
    - 간선에 가중치 ( Weight ) 가 있는 그래프
    - 가중치는 간선의 비용, 거리, 시간 등을 나타낸다
- **이분 그래프 ( Bipartitle Graph )**
    - 무방향 그래프에서, 노드를 두 그룹으로 나누었을 때, 같은 그룹 내의 노드는 서로 인접하지 않고, 다른 그룹의 노드와만 인접하는 그래프
- **비순환 방향 그래프 ( Directed Acyclic Graph )**
    - 사이클이 없는 그래프
    - 방향 그래프에서, 유향 비순환 그래프 ( Directed Acyclic Graph, DAG ) 라고도 한다.

![image](https://github.com/pastjung/DataStructure/assets/87860163/6a5d247d-2064-469c-adbb-a47904201139)

- **완전 그래프 ( Complete Graph )**
    - 모든 노드가 서로 연결된 그래프
    - 노드 수가 n 일 때, 간선의 수는 n * (n-1) / 2 이다
    - 완전 그래프는 항상 연결 그래프를 포함한다
- **부분 그래프 ( Subgraph )**
    - 주어진 그래프의 일부 노드와 간선으로 이루어진 그래프
- **연결 그래프 ( Connected Graph )**
    - 무방향 그래프에서, 모든 노드 사이에 경로가 존재하는 그래프
- **비연결 그래프 ( Disconnected Graph )**
    - 무방향 그래프에서, 연결 그래프가 아닌 그래프
- **강결합 그래프 ( Strongly Connected Graph )**
    - 방샹 그래프에서, 모든 노드 사이에 양방향 경로가 존재하는 그래프

### 그래프 ( Graph ) 구현 방법

### 인접 행렬 ( Adjacency Matrix )
![image](https://github.com/pastjung/DataStructure/assets/87860163/59fa4f98-45d9-49d6-8abe-183a1a8a7103)

- 2차원 배열 ( aka 행렬 ) 을 이용
- 두 개의 노드가 간선으로 연결되어 있다면 인접하다
- 인접 행렬에 그래프의 간선 정보를 저장
- 간선의 존재 유무
    - 간선 (i, j) 가 존재 : [i][j] = 1
    - 간선 (i, j) 가 존재 X : [i][j] = 0

### 장점

- 두 노드의 간선 정보를 확인하는 것이 빠르다 → O(1)
- 새로운 간선을 추가하고 제거하는 것이 빠르다 → O(1)

### 단점

- 간선의 개수와 상관없이 배열의 크기는 항상 N*N 개이다 ( 이때 N 은 노드의 개수 )
→ 즉, O(N^2) 의 메모리를 사용한다
- 특정한 노드에 인접한 노드를 찾기 위해서 모든 노드를 순회해야 한다. → O(N)
- 노드를 추가하거나 제거하는데 오래 걸린다 → O(N^2)
- 그래프의 모든 간선의 수를 찾는데 오래 걸린다 → O(N^2)

### 사용

- 인접 행렬은 상대적으로 노드의 개수가 적고 간선의 수가 많을 때 사용하는 것이 좋다
- 따라서 간선이 많은 밀집 그래프 ( Dense Graph ) 에 적합하다

### 인접 리스트 ( Adjacency List 혹은 Adjacency Array : 인접 배열 )

![image](https://github.com/pastjung/DataStructure/assets/87860163/a8db41a4-022d-4c15-81e7-68c96aa5cb55)

- 인접 정보를 저장하는 리스트
- 연결 리스트의 1차원 배열이다
    - 시작 노드를 기준으로 노드의 개수만큼 연결 리스트가 1차원 배열에 저장된다
- 배열의 크기는 노드의 개수와 같다

### 장점

- 메모리 효율이 좋다
    - 메모리 사용량은 노드 수가 아닌 간선의 수에 따라 달라진다
- 특정 노드에 직접 접근할 수 있어 인접한 노드를 찾기 쉽다
- 노드의 추가 삭제가 빠르다
- 새로운 간선을 빠르게 추가할 수 있다 → O(1)
- 그래프의 모든 간선의 수를 빠르게 찾을 수 있다 → O(N+E)

### 단점

- 두 노드의 간선 정보를 확인하는데 오래 걸린다

### 사용

- 인접 리스트는 노드의 개수가 많고 간선의 개수가 상대적으로 적을 때 사용하는 것이 좋다
- 따라서 간선이 적은 희소 그래프 ( Spare Graph ) 에 적합하다

---
