### 해시 테이블 ( Hash Table ) 이란

![image](https://github.com/pastjung/DataStructure/assets/87860163/8d3c3597-76fa-48f0-b422-1754df6fabe7)


**핵심 내용**

- 테이블 내에 더 작은 서브 그룹인 **버킷 (Bucket) 에 key-value 쌍 (pair) 을 저장**
- Key 를 저장할 때 메모리 공간을 덜 사용하기 위해서, **Key 를 해시 함수 (Hash Function)** 를 통해 **해시(Hash) 라는 특정 숫자값으로 변환**하여 저장
- **필요할 때**만 메모리 크기를 늘리고, 가능한 **작은 크기를 유지**
- 검색된 각 **키**는 미리 정의된 **해시 함수(Hash Function)** 을 통해 **해시(Hash)** 값을 받고 **버킷 (Bucket)** 을 가리킨다.
→ 즉, 해시 (Hash) 값 = 버킷 (Bucket) 의 Index
- 이후 버킷에서 검색할 때 입력된 키를 찾고 **해당 키**와 **관련된 값을 반환**

**요약**

- 해시 테이블이란 → 대량의 정보를 저장하고 특정 요소를 키를 통해 효율적으로 검색할 수 있는 데이터 구조
- 키 (key) : 데이터 검색 시 사용되는 문자열
- 값 (value) : 해당 키와 쌍을 이룬 데이터

**동작 예시**

(Key, Value) 가 (”Jae Hyun”, “1234-5678”) 인 데이터를 크기가 16인 해시 테이블에 저장한다고 가정

1. `int index = Hash_Function(”Jae Hyun”) % 16` 연산을 수행하여 얻은 `Hash 값`을 index 에 저장
2. `array[index] = "1234-5678"` 연산을 수행하여 value 값 저장
3. Key 값으로 데이터를 찾을 때, 해시 함수를 1회 수행하여 데이터를 저장/삭제/조회 를 할 수 있다.

### 시간 복잡도

| 자료 구조 | 검색 (값) | 추가 (add) | 삭제 (delete) |
| --- | --- | --- | --- |
| 해시 테이블 (Hash Table) | O(1) | O(1) | O(1) |
- 단, 데이터의 충돌이 발생한 경우 Chaining 에 연결된 리스트들까지 검색을 해야 하므로 O(n) 까지 시간복잡도가 증가할 수 있다.
- 통계적으로 해시 테이블의 공간 사용률이 70 ~ 80% 정도가 되면 해시의 충돌이 빈번하게 발생하여 성능이 저하되기 시작한다고 한다.

### 장점

- 새로운 요소들의 추가 / 삭제가 용이하고 효율적이다
- 원하는 값의 검색이 빠르고 효율적이다
- 동적인 메모리 크기 ( 단, 직접 크기를 조절해야 한다 )

### 단점

- 충돌이 생길 수 있다 ( 입력된 키의 해시 값이 이미 데이터가 저장된 버킷을 가리킬 수 있다 )
- 충돌이 자주 일어날 수 있으며 해시함수의 정비가 필요한 경우가 많다

### 사용

- 데이터베이스 - ex. 주소 찾기, 이름 찾기, 번호 찾기 등
- 사용자 로그인 인증

### 대표적인 해시 함수 ( Hash Function )

해시 함수에서 중요한 것은 고유한 인덱스 값을 설정하는 것이다.

1. **Division Method** : 나눗셈을 이용한 방법으로 입력값을 테이블의 크기로 나누어 계산
ex. 주소 = 입력된 Key 값 % 테이블의 크기
    - 장점
        - 구현이 간단하고 빠름
        - 일반적으로 좋은 분포를 제공
    - 주의사항
        - 테이블 크기를 소수를 사용하게 될 경우 충돌을 최소화하는 데 조음
        - 2의 제곱수는 충돌이 자주 생기므로 피해야 한다.
2. **Digit Folding** : 각 Key 의 문자열을 ASCII 코드로 바꾸고 값을 합한 데이터를 테이블 내의 주소로 사용하는 방법
    - 과정
        1. Key 의 각 문자를 ASCII 코드로 변환.
        2. 변환된 값들을 합산.
        3. 합산된 값을 테이블 크기로 나눈 나머지를 주소로 사용.
    - 예시
        - Key : “ABC”
        - ASCII 변환 : A = 65, B = 66, C = 67
        - 합산 : 65 + 66 +67 = 198
        - 테이블의 크기가 10인 경우, 주소 = 198 % 10 = 8
    - 장점
        - 문자열 키를 효율적으로 숫자로 변환하여 사용
    - 단점
        - 키가 유사한 문자열일 경우 충돌 가능성이 높음
3. **Multiplication Method** : Key 값을 실수 A(0과 1 사이의 값)와 곱하고 소수점을 버린 후, 나머지 부분을 테이블 크기와 곱하여 주소를 계산하는 방식
    - 공식 : Hash_Function(k) = ( k * A mod 1 ) * m
    ( 이때, k는 키 값, A는 0과 1 사이의 실수, m은 테이블 크기(보통 2의 제곱수) )
    - 과정
        1. k * A를 계산.
        2. 소수점 이하 부분만 남김 (k * A mod 1).
        3. 남은 부분을 m과 곱하여 주소를 구함.
    - 예시
        - 키 값 k = 123
        - A = 0.6180339887 (황금비)
        - 테이블 크기 m = 16 (2^4)
        - 계산: (123 * 0.6180339887 mod 1) * 16 ≈ 7.4 (주소는 7)
    - 장점
        - 테이블 크기에 독립적인 분포를 제공
        - 해시 충돌 가능성이 적음
4. **Univeral Hashing** : 여러 개의 해시 함수를 미리 만들어 두고, 해시 충돌을 줄이기 위해 각 삽입마다 무작위로 해시 함수를 선택하여 해시 값을 생성하는 방법
    - 과정
        1. 해시 함수들의 집합 H를 준비.
        2. 각 키를 해싱할 때마다 H에서 무작위로 하나의 해시 함수를 선택.
        3. 선택한 해시 함수로 해시 값을 계산.
    - 장점
        - 충돌을 효과적으로 줄일 수 있음
        - 공격자가 해시 함수를 예측하여 데이터를 삽입할 가능성을 최소화
    - 단점
        - 여러 해시 함수의 관리가 필요하며 구현이 복잡하다

**요약**

| 함수 | 효과 |
| --- | --- |
| Division Method | 단순하지만 효과적인 방법 |
| Digit Folding | 문자열 키에 유용 |
| Multiplication Method | 고른 분포를 제공하는 방법 |
| Universal Hashing | 충돌을 최소화 할 수 있는 방법 |

### 해시 ( Hash ) 값이 충돌하는 경우

Key 값을 해시 함수 ( Hash Function ) 을 돌려 나온 결과값 해시값이 동일할 경우

### 해결 방법

1. **분리 연결법 ( Separate Chaining )**
    
    ![image](https://github.com/pastjung/DataStructure/assets/87860163/a0e901eb-2b74-48e6-9fa8-10921e4bebba)
    
    - 정의
        - 동일한 버킷의 데이터에 대해 자료구조를 활용해 추가 메모리를 사용하여 다음 데이터의 주소를 저장하는 것
    - 장점
        - 해시 테이블의 확장이 필요 없다
        - 간단하게 구현이 가능하다
        - 손쉽게 삭제할 수 있다
    - 단점
        - 데이터의 수가 많아지면 동일한 버킷에 Chaining 되는 데이터가 많아지며 그에 따라 캐시의 효율성이 감소한다.
2. **개방 주소법 ( Open Addressing )**
    
    ![image](https://github.com/pastjung/DataStructure/assets/87860163/4024e87e-a564-4fc1-8151-067ef76ad6ab)
    
    - 정의
        - 추가적인 메모리를 사용하는 Chaining 방식과 다르게 비어있는 해시 테이블의 공간응 활용하는 방법
    - Open Addressing 을 구현하기 위한 대표적인 방법 3가지
        1. **Linear Probing** : 현재의 버킷 Index 로부터 고정폭 만큼씩 이동하여 차례대로 검색해 비어 있는 버킷에 데이터를 저장
        2. **Quadratic Probing** : 해시의 저장순서 폭을 제곱으로 저장하는 방식
        ex. 처음 충돌이 발생한 경우 → 1만큼 이동,
        그 다음 계속 충돌이 발생할 경우 → 2 ^ 2,
        그 다음 충돌이 발생할 경우 → 3 & 2 칸씩 옮기는 방식
        3. **Double Hashing Probing** : 해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애버리는 방식
        → 해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 된다.
        
        → Open Addressing에서 데이터를 삭제하면 삭제된 공간은 Dummy Space로 활용되는데, 그렇기 때문에 Hash Table을 재정리 해주는 작업이 필요하다고 한다
        

### Java 의 해시 맵 ( HashMap ) VS 해시 테이블 ( Hash Table )

해시 맵과 해시 테이블 모두 해시 Key-Value 쌍을 저장하는 데이터 구조

- **HashMap** : 동기화되지 않아서 멀티스레드 환경에서 안전하지 않다.
→ 여러 스레드가 동시에 HashMap 을 수정하면 예상치 못한 결과가 생길 수 있다
→ 동기화되지 않은 대신 일반적으로 HashTable 보다 빠르다
- **HashTable** : 동기화되어 있어서 멀티스레드 환경에서 안전하다.

---
